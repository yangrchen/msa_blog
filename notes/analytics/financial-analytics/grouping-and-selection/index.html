<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yang Chen">
<meta name="dcterms.date" content="2024-01-08">

<title>Yang MSA - Scorecard Variable Grouping and Selection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<link href="../../../../favicon.ico" rel="icon">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">Yang MSA</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../notes/index.html" rel="" target="">
 <span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../blog/index.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/yangrchen" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Scorecard Variable Grouping and Selection</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">analytics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Yang Chen </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 8, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#variable-grouping" id="toc-variable-grouping" class="nav-link active" data-scroll-target="#variable-grouping"><span class="header-section-number">1</span> Variable Grouping</a>
  <ul class="collapse">
  <li><a href="#initial-characteristic-analysis" id="toc-initial-characteristic-analysis" class="nav-link" data-scroll-target="#initial-characteristic-analysis"><span class="header-section-number">1.1</span> Initial Characteristic Analysis</a></li>
  </ul></li>
  <li><a href="#weight-of-evidence" id="toc-weight-of-evidence" class="nav-link" data-scroll-target="#weight-of-evidence"><span class="header-section-number">2</span> Weight of Evidence</a></li>
  <li><a href="#information-value" id="toc-information-value" class="nav-link" data-scroll-target="#information-value"><span class="header-section-number">3</span> Information Value</a></li>
  <li><a href="#gini-statistic" id="toc-gini-statistic" class="nav-link" data-scroll-target="#gini-statistic"><span class="header-section-number">4</span> Gini Statistic</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="variable-grouping" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Variable Grouping</h1>
<p>Scorecards end up with only just groups within a variable.</p>
<p><strong>Objectives:</strong></p>
<ul>
<li>Eliminate weak characteristics or those that do not conform to good business logic.</li>
<li>Group the strongest characteristics’ attribute levels in order to produce a model in scorecard format.</li>
</ul>
<p>In R, we have the <code>smbinning</code> package and in Python we have the <code>scorecard</code> or <code>OptBinning</code> packages.</p>
<p><strong>Goals:</strong></p>
<ul>
<li>Useful for understanding relationships.</li>
<li>Modeling nonlinearities similar to decision trees.</li>
<li>Dealing with outliers contianed in the smallest / largest group.</li>
<li>Missing values tend to typically go in their own group.</li>
</ul>
<section id="initial-characteristic-analysis" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="initial-characteristic-analysis"><span class="header-section-number">1.1</span> Initial Characteristic Analysis</h2>
<p>Need a starting point for the grouping / binning. We tend to use quantiles for this initial approach. The idea is to pre-bin the interval variables into a number of user-specified quantiles / buckets for fine detailed groupings. We can then aggregate the fine detailed groupings into a smaller number to produce coarse groupings using chi-squared tests to combine groups. Only groups next to each other are grouped.</p>
<p>In R, we can use decision trees to select cut points for the variables. Specifically, we use conditional inference trees. CART methods have inherent bias as variables with more levels are more likely to be split on using Gini and entropy. CIT method adds an extra statistical step before splits occur using statistical tests of significance (Chi-square) to inform splits.</p>
<p>Each time we split, we use statistical tests on our response from the chunks created from the last split.</p>
<div id="fig-cit-method" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/cit-method.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: CIT Method</figcaption>
</figure>
</div>
<p>Cutoffs may be rough from decision tree combining. We can optionally override these generated groups to conform to business rules, but overrides may make groups suboptimal.</p>
</section>
</section>
<section id="weight-of-evidence" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Weight of Evidence</h1>
<p><strong>Weight of evidence (WOE)</strong> measures the strength of the attributes of a characteristic in separating good and bad accounts. WOE is based on comparing the proportion of goods to bads at each attribute level.</p>
<p><span class="math display">\[
WOE_i = \log(\frac{Dist.Good_i}{Dist.Bad_i})
\]</span></p>
<ul>
<li><span class="math inline">\(Dist.Good_i = \frac{\text{# Good in group i}}{\text{Total # Good}}\)</span></li>
<li><span class="math inline">\(Dist.Bad_i = \frac{\text{# Bad in group i}}{\text{Total # Bad}}\)</span></li>
</ul>
<p>We’re looking for big differences in WOE between groups. With interval variables we are looking for monotonic changes within an attribute. Going back and forth between positive and negative values of WOE typically signal variables have trouble separating good vs.&nbsp;bad. However, this is not always required it it makes business sense–credit card utilization for example.</p>
<div id="fig-woe-example" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/woe-example.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: WOE Example</figcaption>
</figure>
</div>
<p>WOE from <a href="#fig-woe-example">Figure&nbsp;2</a> is essentially looking at the difference between the proportion of bads and proportion of goods on a natural log scale. We can see that there is a monotonically increasing difference up until the missing category. As we move up through the different categories, there is a greater proportion of goods.</p>
<ul>
<li>WOE approximately 0 implies % of good is approximately equal to % of bad so group doesn’t separate good vs.&nbsp;bad well.</li>
<li>WOE positive implies group identifies people who are good.</li>
<li>WOE negative implies group identifies people who are bad.</li>
</ul>
<p>After the binning, quasi-complete separation can still be a problem. We can use adjusted WOE to account for possible quasi-complete separation:</p>
<p><span class="math display">\[
\text{Adjusted} WOE_i = \log(\frac{Dist.Good_i + \eta_1}{Dist.Bad_i + \eta_2})
\]</span></p>
<ul>
<li><span class="math inline">\(\eta_1\)</span> and <span class="math inline">\(\eta_2\)</span> parameters are smoothing parameters that correct for potential overfitting and protect against quasi-complete separation</li>
<li>Most software just set <span class="math inline">\(\eta_1 = \eta_2\)</span> and has one parameter</li>
</ul>
</section>
<section id="information-value" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Information Value</h1>
<p>Across all the categories in this variable, how good do we separate out the 1’s and 0’s? <strong>Information value</strong> measures the ability of the characteristic to separate goods vs.&nbsp;bads.</p>
<p><span class="math display">\[
IV = \sum_{i=1}^{L} (Dist.Good_i - Dist.Bad_i) \cdot \log(\frac{Dist.Good_i}{Dist.Bad_i})
\]</span></p>
<p>Overall, bigger is better with information value. Some rules of thumb:</p>
<ul>
<li><span class="math inline">\(IV &lt; 0.02\)</span>: Not predictive</li>
<li><span class="math inline">\(0.02 &lt; IV &lt; 0.1\)</span>: Weak predictor</li>
<li><span class="math inline">\(0.1 &lt; IV &lt; 0.25\)</span>: Medium predictor</li>
<li><span class="math inline">\(0.25 &lt; IV\)</span>: Strong predictor</li>
</ul>
<p>IV allows us to do variable selection since we are aggregating groups across the entire variable. Using the cutoffs, we can select variables that we should include in our model.</p>
<p>In the world of credit modeling, a hard cutoff for selecting variables is greater than 0.1.</p>
<p>Keep in mind that in R all variables that we are binning must be encoded as factors. <code>smbinning</code> will point out which variables it believes shouldn’t be binned due to not enough unique values or any variables which have no significant splits.</p>
<p>A caveat to the cutoffs is <span class="math inline">\(IV &gt; 0.5\)</span>. At this point, we might believe the variable is over-predicting. An overpredicting example: All previous mortgage decisions have been made only on bureau score so of course bureau score is highly predictive–variable becomes significant. A common practice is to create two models–one with bureau score, one without–and ensemble.</p>
</section>
<section id="gini-statistic" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Gini Statistic</h1>
<p><strong>Gini statistic</strong> is an optional technique that tries to answer the same questions as IV–which variables are strong enough to enter the scorecard model?</p>
<p>IV is more in line with WOE calculation and used more often.</p>
<ul>
<li>Range is 0 to 100.</li>
<li>Bigger is better.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>