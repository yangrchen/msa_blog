{
  "hash": "dc528e203d5cf948f258604d381637f3",
  "result": {
    "markdown": "---\ntitle: Git Basics\ndate: 09/20/2023\nengine: knitr\n---\n\n\n# Getting Started\n\nYou'll need to have Git installed on your computer first before, well... using Git. \n\nYou can find an installation for your operating system on the [Git website](https://git-scm.com/downloads). Whichever way you install Git, make sure you install the application to your PATH if given the option to do so. For Windows, make sure to select **\"Use Git from the Windows Command Prompt\"** option.\n\nWe'll be using the (dreaded) command line! It's useful to get comfortable working your way around the command line even while graphical user interface (GUI) apps exist like Github Desktop. Command lines are fairly agnostic and during the practicum we don't have the luxury of using Github Desktop anyhow. \n\nIt's not scary; it's not magic. It's just carpal tunnel waiting to happen.\n\n:::{.panel-tabset group=\"os-terminals\"}\n# Windows\n\nSome of the basic terminal commands aren't named the same between Unix and Windows terminals. If you want one-to-one compatibility between the non-Git commands here, then you can use **Git Bash**.\n\nIf you installed Git Bash, then you can search for it in your applications and run this. All the commands I show will be available there and will run.\n\nOtherwise, Windows has Command Prompt or Powershell depending on what you prefer. You can run Command Prompt by either looking for it in your apps or searching `cmd` after hitting `Win` + `R`.\n\nCheck to see that you have Git installed:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit -v\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ngit version 2.42.0\n```\n:::\n:::\n\n\n# MacOS\n\nMacOS has a native **Terminal** app that you can search for by using Spotlight (`âŒ˜` + `Space`). \n\nCheck to see that you have Git installed:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit -v\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ngit version 2.42.0\n```\n:::\n:::\n\n:::\n\n# Git as a Version Control System\n\nGit is a **distributed version control system (DVCS)**. What this means is that every user computer **clones the server file repository along with that repository's history**. Even if the server repository goes down, we still have the cloned repositories that we can use to back up the server. Contrast this to a **centralized** repository where we're constantly pushing and pulling files from a single centralized server.\n\nGit works a little differently from other VCS in that it takes **snapshots** of your files every time you commit your work. Each snapshot represents the state of your files at any given commit. Many older VCS take a **delta-based** approach which show you what files changes have been made from the base files. Snapshots allow for clear representations of a project's history at any commit and direct comparisons between two different commits. \n\nIf a file hasn't changed, then Git provides a reference to the last identical file to save space. Essentially, we're not just saving changes we have our own mini filesystem and that gives us a lot of opportunity.\n\nThat's about as much background into version control systems as I'll go into. Let's run some commands!\n\n![Centralized vs. Distributed Version Control](images/vcs-type-diagrams.jpeg){#fig-centralized-distributed-vcs}\n\n# Basic Git Workflow\n\nWe'll be working with a pre-existing repository. You won't be able to push changes to the server without being a collaborator, but all the commands I will be showing here apply all the same.\n\nThe basic workflow goes something like this:\n\n\n```{mermaid}\nflowchart LR\n    A[Pull/Clone repository] --> B[Do some work]\n    B --> C[Stage/Unstage changes]\n    C --> D[Commit your work]\n    D --> E[Push your work to the server]\n```\n\n\nWe'll also go over how to view the commit history, see differences between files, and monitor other useful activity.\n\n# Cloning a Repository\n\n**Cloning** a repository refers to getting a copy of an existing Git repository from the server. We use `git clone <repository-link>` to grab a full copy of the files along with file history. You should see a new directory with the repository's name.\n\nLet's clone the example repository now and change into the directory:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit clone https://github.com/msa2024-hackers/msa-share20-gitdemo.git\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nCloning into 'msa-share20-gitdemo'...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_knit$set(root.dir = \"msa-share20-gitdemo\")\n```\n:::\n\n\n:::{.panel-tabset group=\"os-terminals\"}\n# Windows\n```{.bash filename=\"Terminal\"}\ndir\ncd msa-share20-gitdemo\n```\n\n```{}\n...\nmsa-share20-gitdemo\n```\n\n```{.bash filename=\"Terminal\"}\ndir\n```\n\n```{}\nREADME.md\na.txt\nb.txt\nc.txt\ndont-run-this.py\n```\n\n# MacOS\n\n```{.bash filename=\"Terminal\"}\nls\ncd msa-share20-gitdemo\n```\n\n```{}\n...\nmsa-share20-gitdemo\n```\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\nls\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nREADME.md\na.txt\nb.txt\nc.txt\ndont-run-this.py\n```\n:::\n:::\n\n\n:::\n\nYou now have a clone of the server repository on your local machine and you can start committing (making snapshots) of any work you do!\n\n# Tracking Your Work\n\nFiles have two states: **untracked** and **tracked**. \n\n## Tracked Files\n\n**Tracked files** are any files that you add to your staging area--also called the **index**--or were in the previous snapshot. \n\nFor example, all the files we listed out (e.g. {a-b}.txt) from the `ls` command came from the current snapshot of the repository so they are already tracked. If we had created a local repository from scratch using `git init` then every file would initially start untracked.\n\nTracked files have three sub-states:\n\n-   Unmodified\n-   Modified\n-   Staged\n\n## Untracked Files\n\n**Untracked files** are any files not in the last snapshot and not in the staging area.\n\n![Git Staging Lifecycle](images/git-stage-lifecycle.jpeg){#fig-staging-lifecycle}\n\n## Check File Status\n\nHow can we see what state our files are in? There's the handy dandy `git status` command!\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n```\n:::\n:::\n\n\nWe haven't changed added, modified, or staged any files yet. Let's do that now:\n\n:::{.panel-tabset group=\"os-terminals\"}\n# Windows\n\n```{.bash filename=\"Terminal\"}\ncopy crazy-cats.txt+\ngit status\n```\n\n```{}\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n    crazy-cats.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n# MacOS\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ntouch crazy-cats.txt\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tcrazy-cats.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n:::\n:::\n\n:::\n\n`crazy-cats.txt` is currently untracked. And like the blackbox magician is suggesting, we can use `git add` to track the file:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit add crazy-cats.txt\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   crazy-cats.txt\n```\n:::\n:::\n\n\nThe argument for `git add <arg>` can take in a path name for a file or a directory. If it's a directory, then the command recursively adds all files in the directory:\n\n:::{.panel-tabset group=\"os-terminals\"}\n# Windows\n\n```{.bash filename=\"Terminal\"}\nmkdir crazy-pets\ncopy crazy-pets/crazy-dogs.txt+\n```\n\n# MacOS\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\nmkdir crazy-pets\ntouch crazy-pets/crazy-dogs.txt\n```\n:::\n\n:::\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit add crazy-pets\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   crazy-cats.txt\n\tnew file:   crazy-pets/crazy-dogs.txt\n```\n:::\n:::\n\n\nNote that when you `git add` you are staging files at the **current state the file was in at the time of the command**. What this means is that if you make any additional changes that you want to be committed then you should rerun the `git add` command: \n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\necho \"meow\" >> crazy-cats.txt\necho \"bbbb\" >> b.txt\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   crazy-cats.txt\n\tnew file:   crazy-pets/crazy-dogs.txt\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   b.txt\n\tmodified:   crazy-cats.txt\n```\n:::\n:::\n\n\n`crazy-cats.txt` shows up again under **\"Changes not staged for commit\"** because we started tracking the last state of the file (\"Changed to be commited\") but we now have a new current working state which is different.\n\n`git status` also has a shorthand flag `-s` which is less verbose:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit status -s\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n M b.txt\nAM crazy-cats.txt\nA  crazy-pets/crazy-dogs.txt\n```\n:::\n:::\n\n\n- `M` stands for modified\n- `A` stands for added\n- `??` stand for untracked\n\nThe left hand column refers to the file status in the staging area while the right hand column refers to the file status in the working tree. For example, `MM` would stand for a modified file in both the staging area and the working tree.\n\nI made a change to `b.txt` but I \"forgot\" about it and don't actually want to commit it. I also changed my mind about staging `crazy-cats.txt`. What can I do?\n\n# Restoring / Undoing Your Work\n\nSo far we have learned how to track and stage our work. However, let's say we staged a file or set of files that we don't actually want to stage. \n\nWe use `git restore --staged <path>` to unstage a file. \n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit restore --staged crazy-cats.txt\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   crazy-pets/crazy-dogs.txt\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   b.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tcrazy-cats.txt\n```\n:::\n:::\n\n\nIf we leave out the `--staged` flag then the restore command can actually restore a file to the last committed version--this will discard any uncommitted local changes you made to a file.\n\n:::{.callout-warning}\n`git restore` for discarding local changes cannot be undone. Make sure you actually don't need the changes before running this command.\n:::\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit restore b.txt\ngit status -s\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nA  crazy-pets/crazy-dogs.txt\n?? crazy-cats.txt\n```\n:::\n:::\n\n\n:::{.callout-note}\n`git restore` was introduced in Git v.2.23.0. Previously, we had to use `git reset HEAD <file>` to unstage files and `git checkout -- <file>` to discard changes in the working directory.\n:::\n\n# Committing Your Work\n\nWhenever we **commit** our work, we can think of Git as writing the state of our files in the staging area--the snapshot--into a logbook. Glory to us; our work will go down into the pages of (our specific codebase repository) history!\n\n`git commit` creates a new commit from our staged files. If you just run the command without any additional flags then it will open up some editor (e.g. Vim, nano, etc.) for you to view your commit and write a message for it. In this case, I will only show you the shorthand for creating a commit with a message describing the changes.\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit commit -m \"Story X: Added crazy-pets files\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n[main c2c6661] Story X: Added crazy-pets files\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 crazy-pets/crazy-dogs.txt\n```\n:::\n:::\n\n\nThe output tells us some useful information like which branch the commit we committed on, the commit ID, and the types of changes we made. Once we make an official commit, we can always revert to or compare with it. \n\nIf we want to skip the staging area and automatically stage every file that was already tracked before the commit (e.g. modified files) then we can use `git commit -a`. If you want to combine the `-m` and `-a` flag the command would look like this:\n\n```{.bash filename=\"Terminal\"}\ngit commit -am \"Story A: Automatically staging cool stuff\"\n```\n\n:::{.callout-note}\nThere are special git commands `git rm` and `git mv` to account for removing or moving files. However, those operations follow the same general process as adding and modifying files. We do some work, add our changes to the staging area, and then make a commit for them.\n:::\n\n# Viewing Commits\n\nWe use `git log` to read the logbook of past commits. Commits show up in reverse chronological order.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncommit c2c66619adc205174e5211e8ebae9f4b6cffe23b\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Oct 5 11:38:55 2023 -0400\n\n    Story X: Added crazy-pets files\n\ncommit e788bdc76928fc02e7827bc9b6b74505c0b20b6e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:47:53 2023 -0400\n\n    Added B, C.txt files\n\ncommit 01de929a8d41075dd2cc7a43c0d06a01fb0a6eae\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:47:30 2023 -0400\n\n    Added a.txt file\n\ncommit 9545b4cbb1d4f3e7f8a84914d270dcf05b37405e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:45:43 2023 -0400\n\n    Added efficient Python algorithms\n\ncommit b8cff78ebbd5db58403b168b9bb68a4043401a95\nAuthor: Yang Chen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:20:00 2023 -0400\n\n    Initial commit\n```\n:::\n:::\n\n\nTo view the first `n` commits:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log -2\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncommit c2c66619adc205174e5211e8ebae9f4b6cffe23b\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Oct 5 11:38:55 2023 -0400\n\n    Story X: Added crazy-pets files\n\ncommit e788bdc76928fc02e7827bc9b6b74505c0b20b6e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:47:53 2023 -0400\n\n    Added B, C.txt files\n```\n:::\n:::\n\n\nHowever, we're not just limited to the default output. There are a variety of options that we have to display different types of information. For example, if we want to see some stats (number of added lines, modifications, etc.) for each commit we can use the `--stat` flag:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --stat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncommit c2c66619adc205174e5211e8ebae9f4b6cffe23b\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Oct 5 11:38:55 2023 -0400\n\n    Story X: Added crazy-pets files\n\n crazy-pets/crazy-dogs.txt | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n\ncommit e788bdc76928fc02e7827bc9b6b74505c0b20b6e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:47:53 2023 -0400\n\n    Added B, C.txt files\n\n b.txt | 0\n c.txt | 0\n 2 files changed, 0 insertions(+), 0 deletions(-)\n\ncommit 01de929a8d41075dd2cc7a43c0d06a01fb0a6eae\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:47:30 2023 -0400\n\n    Added a.txt file\n\n a.txt | 60003 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n 1 file changed, 60003 insertions(+)\n\ncommit 9545b4cbb1d4f3e7f8a84914d270dcf05b37405e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:45:43 2023 -0400\n\n    Added efficient Python algorithms\n\n dont-run-this.py | 4 ++++\n 1 file changed, 4 insertions(+)\n\ncommit b8cff78ebbd5db58403b168b9bb68a4043401a95\nAuthor: Yang Chen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:20:00 2023 -0400\n\n    Initial commit\n\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n```\n:::\n:::\n\n\nWe can also output a completely custom output using the `--pretty=format` setting which lets you put in format specifiers:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --pretty=format:\"%h / %an / %ad\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nc2c6661 / yangrchen / Thu Oct 5 11:38:55 2023 -0400\ne788bdc / yangrchen / Thu Sep 21 22:47:53 2023 -0400\n01de929 / yangrchen / Thu Sep 21 22:47:30 2023 -0400\n9545b4c / yangrchen / Thu Sep 21 22:45:43 2023 -0400\nb8cff78 / Yang Chen / Thu Sep 21 22:20:00 2023 -0400\n```\n:::\n:::\n\n\nIn this case I'm outputting the abbreviated commit hash, the author name, and the date of the commit. A few useful specifiers are listed in @tbl-format-specifiers.\n\n| Specifier | Description of Output\n| -------- | ---------------------\n| `%H`     | Commit hash\n| `%h`     | Abbreviated commit hash\n| `%T`     | Tree hash\n| `%t`     | Abbreviated tree hash\n| `%P`     | Parent hashes\n| `%p`     | Abbreviated parent hashes\n| `%an`    | Author name\n| `%ae`    | Author email\n| `%ad`    | Author date\n| `%cn`    | Committer name\n| `%ce`    | Committer email\n| `%cd`    | Committer date\n| `%cr`    | Committer date, relative\n| `%s`     | Subject\n\n: Useful Format Specifiers {#tbl-format-specifiers}\n\nA really useful feature is being able to specify a file path to see only commits that involve that file:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit log -- dont-run-this.py\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncommit 9545b4cbb1d4f3e7f8a84914d270dcf05b37405e\nAuthor: yangrchen <yangrc.chen@gmail.com>\nDate:   Thu Sep 21 22:45:43 2023 -0400\n\n    Added efficient Python algorithms\n```\n:::\n:::\n\n\n# Pushing Your Work to a Remote\n\nRemote repositories are repositories hosted on the Internet or another network. Although we typically think of remote repositories as being on a separate machine, you can actually have a remote repository locally. \n\nIf you recall the DVCS diagram, each of those separate cloned repositories could be a remote. However, in a single team use case like our practicum we might just have a single remote that we are pushing and pulling from. \n\nRemote repositories are what make collaboration possible. If we know how to use remotes then we can effectively work between different users while having a reliable codebase to work on.\n\nTo see your remotes, run `git remote`. The `-v` flag shows the URLs that the remote shortnames refer to:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit remote\ngit remote -v\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\norigin\norigin\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (fetch)\norigin\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (push)\n```\n:::\n:::\n\n\n## Adding a Remote\n\nIf we want to manually add a new remote we can use `git remote add <remote-name> <URL>`\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit remote add yang https://github.com/msa2024-hackers/msa-share20-gitdemo.git\ngit remote -v\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\norigin\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (fetch)\norigin\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (push)\nyang\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (fetch)\nyang\thttps://github.com/msa2024-hackers/msa-share20-gitdemo.git (push)\n```\n:::\n:::\n\n\n## Fetching / Pulling a Remote\n\nWe need some way to get the work that others have pushed up to the remotes you have configured. To do that, we use `git fetch` or `git pull`.\n\nThe fundamental difference between these two commands is that **fetching** downloads the data to your local repository **but it doesn't automatically merge it with your working directory**. You have to manually merge it in yourself. **Pulling** will both fetch and then merge the changes into your working directory. \n\nThere is a more nuanced explanation to this difference, but for a basic workflow a single team will most likely only have to use `git pull`.\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit pull\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nAlready up to date.\n```\n:::\n:::\n\n\n## Removing a Remote\n\nTo remove a remote, we use `git remote remove <remote-name>`:\n\n\n::: {.cell filename='Terminal'}\n\n```{.bash .cell-code}\ngit remote remove yang\n```\n:::\n\n\n## Pushing to a Remote\n\nFinally! The last command and then we're one step closer to Git mastery! \n\nTo share our work with a remote repository, we **push** to the upstream. We use `git push <remote> <branch>` to push our code to the remote. Branches are outside the scope of this article, but you typically have the `main` branch when you clone a repository by default.\n\n```{.bash filename=\"Terminal\"}\ngit push origin main\n```\n\nAgain, if you were working with a repository that you had write permissions to then you could navigate over to Github or the designated Git server and find your work on the remote repository!\n\n# Conclusion\n\nGit is an effective solution to version control that allows multiple users to monitor and contribute to codebases in a stable manner. For a basic workflow, you will pull the new changes, do some work, make a commit, and then push out your changes for others to view and use. There are **a lot** of features to Git--the ones I'm showing here can still get you very far.\n\nHowever, don't think of this workflow as your ultimate solution for file collaboration in Git. Effective communication is still necessary to make sure you don't clobber each other's work. Make sure to carefully review commits and if necessary look farther into Git's documentation to iron out any issues / scale up as the collaboration grows more complex.\n\n<!-- Cells to run for cleanup -->\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}