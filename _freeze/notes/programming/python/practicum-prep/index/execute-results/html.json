{
  "hash": "9c83383a09a44e9fbc46212fff6386e9",
  "result": {
    "markdown": "---\ntitle: Pandas Primer 1\ndate: 09/14/2023\n---\n\n![All Python Data Scientists Currently](images/pandas.jpeg)\n\n# Setup {.unnumbered}\n\nI won't go into a lot of a detail about the use of virtual environments in Anaconda, but ideally we should have a separate environment for separate projects. If you install everything into a single environment (`base` for example) you can run into hard-to-debug dependency issues when different projects require different versions of your packages.\n\nOpen your favorite terminal and run these commands to create a new Anaconda environment called `python-eda` and install `python`, `numpy`, and `pandas`.\n\n```{.bash filename=\"Terminal\"}\nconda create -n python-eda\nconda activate python-eda\nconda install python=3.11 numpy pandas\n```\n\nWe'll then import all the packages we'll need to run our delicious code!\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n\n# Introduction\n\n`pandas` is a popular data analysis and manipulation package that is designed for working with tabular or heterogeneous data. Think about it like working on a dataset with many different types of fields: continuous, text, categorical, dates, etc. No images though--we keep it all numerical up in here.\n\nThere are two main data structures in `pandas`:\n\n-   **Series**\n-   **DataFrame**\n\nWe'll be going over what these two data structures are doing and what operations we can do with them. Long story short: there's a lot, but there's just a few tools you need to move your way around. \n\n`pandas` is built on top of functionality from `numpy`. Many of the functions and methods that operate on Series and DataFrames work in concordance with `numpy` with techniques like *broadcasting*. A lot of the same operations you can do in `numpy` can also work in `pandas`.\n\n# Series\n\nSeries is a one-dimensional *array-like* object with a sequence of values having the **same type** and an array of data labels called the **index**. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nseries = pd.Series([1, 2, 3])\nseries\n```\n\n::: {.cell-output .cell-output-display execution_count=170}\n```\n0    1\n1    2\n2    3\ndtype: int64\n```\n:::\n:::\n\n\n## Indexing into Series\n\nNotice how by default each entry in the series is labeled from 0 to $n - 1$. This is the index. We can set our own index for the Series and retrieve values using the index:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nseries = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\nprint(series)\nprint(series['b'])\nprint(series[['a', 'b']])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    1\nb    2\nc    3\ndtype: int64\n2\na    1\nb    2\ndtype: int64\n```\n:::\n:::\n\n\nThe index is ordered according to the data, so we can also slice using the index. Unlike Python lists, both ends are inclusive:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(series['a':'b'])\n\n# This is similar to saying list[2:0]\nprint(series['b':'a'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    1\nb    2\ndtype: int64\nSeries([], dtype: int64)\n```\n:::\n:::\n\n\n## Series Are Similar to Numpy Arrays!\n\nYou can use Boolean arrays and do vectorized operations like scalar multiplication just like with `numpy` arrays.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nseries = pd.Series(np.arange(9))\n\nprint(series[series > 5])\nprint(series * 5)\nprint(np.square(series))\nprint(series.argmax())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6    6\n7    7\n8    8\ndtype: int64\n0     0\n1     5\n2    10\n3    15\n4    20\n5    25\n6    30\n7    35\n8    40\ndtype: int64\n0     0\n1     1\n2     4\n3     9\n4    16\n5    25\n6    36\n7    49\n8    64\ndtype: int64\n8\n```\n:::\n:::\n\n\n## Converting Python Dictionaries to Series\n\nWe can provide a dictionary as a Series which automatically converts the dictionary keys into the index:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nd = {\"Apples\": 2, \"Bananas\": 5, \"Oranges\": 18}\nseries = pd.Series(d)\n```\n:::\n\n\nAnd then back into a dictionary with the `to_dict` method:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nseries.to_dict()\n```\n\n::: {.cell-output .cell-output-display execution_count=175}\n```\n{'Apples': 2, 'Bananas': 5, 'Oranges': 18}\n```\n:::\n:::\n\n\n## Series in Data Analysis\n\nChecking for missing values:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nseries = pd.Series(d, index = [\"Apples\", \"Bananas\", \"Mangoes\"])\nprint(series.isna())\nprint(series.notna())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nApples     False\nBananas    False\nMangoes     True\ndtype: bool\nApples      True\nBananas     True\nMangoes    False\ndtype: bool\n```\n:::\n:::\n\n\nWhen you add Series together, it automatically aligns the labels together and NAs the values where the indexes are not the same.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nd = {\"Apples\": 60, \"Bananas\": 20, \"Durian\": 10, \"Avocados\": 10}\nseries2 = pd.Series(d)\n\nseries + series2\n```\n\n::: {.cell-output .cell-output-display execution_count=177}\n```\nApples      62.0\nAvocados     NaN\nBananas     25.0\nDurian       NaN\nMangoes      NaN\ndtype: float64\n```\n:::\n:::\n\n\n## Series Name\n\nA Series index and its data values have a special `name` attribute which integrates with other functionality in `pandas`:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nseries.name = \"count\"\nseries.index.name = \"fruit\"\nseries\n```\n\n::: {.cell-output .cell-output-display execution_count=178}\n```\nfruit\nApples     2.0\nBananas    5.0\nMangoes    NaN\nName: count, dtype: float64\n```\n:::\n:::\n\n\n# DataFrame\n\nA DataFrame is a tabular form data structure. It contains an ordered, named collection of columns which can have different types. Think of DataFrames in the same way that you think of structured datasets or even R dataframes!\n\nA DataFrame has a row and column index. How does this relate to series? Essentially, a DataFrame is a dictionary of Series that share the same index.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndata = {\n    \"is_student\": [True, False, True, True, True],\n    \"name\": [\"Bill\", \"Jill\", \"Davis\", \"Cythulianmixseth III\", \"Jonny\"],\n    \"score\": [10, 20, 30, 20, 10],\n}\ndf = pd.DataFrame(data)\n```\n:::\n\n\n## Viewing the First N Rows, Last N Rows\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nn = 2\nprint(df.head(n))\nprint(df.tail(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   is_student  name  score\n0        True  Bill     10\n1       False  Jill     20\n   is_student                  name  score\n3        True  Cythulianmixseth III     20\n4        True                 Jonny     10\n```\n:::\n:::\n\n\n## Specifying Columns\n\nJust like Series, you can specify the names of columns. If the column names exist, then the DataFrame will be ordered by the order you specified them. Otherwise, the column will be inserted with NA values.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndf2 = pd.DataFrame(data, columns = [\"name\", \"score\", \"is_student\"])\ndf2\n```\n\n::: {.cell-output .cell-output-display execution_count=181}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>name</th>\n      <th>score</th>\n      <th>is_student</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Bill</td>\n      <td>10</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Jill</td>\n      <td>20</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Davis</td>\n      <td>30</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Cythulianmixseth III</td>\n      <td>20</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Jonny</td>\n      <td>10</td>\n      <td>True</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndf2 = pd.DataFrame(data, columns=[\"a\", \"b\", \"is_student\"])\ndf2\n```\n\n::: {.cell-output .cell-output-display execution_count=182}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>a</th>\n      <th>b</th>\n      <th>is_student</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>True</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Retrieving Columns\n\nTo retrieve columns, use dictionary-like notation or use the dot notation.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(df[\"is_student\"])\nprint(df.is_student)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0     True\n1    False\n2     True\n3     True\n4     True\nName: is_student, dtype: bool\n0     True\n1    False\n2     True\n3     True\n4     True\nName: is_student, dtype: bool\n```\n:::\n:::\n\n\n:::{.callout-caution}\n# Dot Notation\n\nThe main downside of dot notation is that you can't use it if it's not a valid Python variable name, conflicts with method names in DataFrame, or has whitespaces. Learn to not rely on dot notation.\n:::\n\n## Modifying Columns, Adding Columns\n\nYou can change column values by assigning a new value. If you assign a Series, then the labels will be aligned to the DataFrame's index and insert NA where index values are not present:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndf[\"score\"] = 1.\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=184}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>is_student</th>\n      <th>name</th>\n      <th>score</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>True</td>\n      <td>Bill</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>False</td>\n      <td>Jill</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>True</td>\n      <td>Davis</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>True</td>\n      <td>Cythulianmixseth III</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>True</td>\n      <td>Jonny</td>\n      <td>1.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nval = pd.Series([2, 2], index=[2, 4])\ndf[\"score\"] = val\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=185}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>is_student</th>\n      <th>name</th>\n      <th>score</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>True</td>\n      <td>Bill</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>False</td>\n      <td>Jill</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>True</td>\n      <td>Davis</td>\n      <td>2.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>True</td>\n      <td>Cythulianmixseth III</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>True</td>\n      <td>Jonny</td>\n      <td>2.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNote that any column retrieved from a DataFrame is a view on the data, not a copy. Any modifications to this Series will be reflected in the DataFrame.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nscore = df[\"score\"]\nscore[0] = 1.\n\n# DataFrame is modified as a result of changing the view\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/7s/plv7qn294jg_4c9nxj_69_380000gn/T/ipykernel_79201/2353297564.py:2: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=186}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>is_student</th>\n      <th>name</th>\n      <th>score</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>True</td>\n      <td>Bill</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>False</td>\n      <td>Jill</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>True</td>\n      <td>Davis</td>\n      <td>2.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>True</td>\n      <td>Cythulianmixseth III</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>True</td>\n      <td>Jonny</td>\n      <td>2.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Transpose\n\nTo transpose the data:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndf.T\n```\n\n::: {.cell-output .cell-output-display execution_count=187}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>is_student</th>\n      <td>True</td>\n      <td>False</td>\n      <td>True</td>\n      <td>True</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>name</th>\n      <td>Bill</td>\n      <td>Jill</td>\n      <td>Davis</td>\n      <td>Cythulianmixseth III</td>\n      <td>Jonny</td>\n    </tr>\n    <tr>\n      <th>score</th>\n      <td>1.0</td>\n      <td>NaN</td>\n      <td>2.0</td>\n      <td>NaN</td>\n      <td>2.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::{.callout-caution}\nTransposing discards column data types of columns do not all have the same type. Transposing back may lose previous type information.\n:::\n\n## DataFrame Column and Index Names\n\nJust like Series, you can name the index and columns of the DataFrame:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndf.index.name = \"student\"\ndf.columns.name = \"information\"\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=188}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>information</th>\n      <th>is_student</th>\n      <th>name</th>\n      <th>score</th>\n    </tr>\n    <tr>\n      <th>student</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>True</td>\n      <td>Bill</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>False</td>\n      <td>Jill</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>True</td>\n      <td>Davis</td>\n      <td>2.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>True</td>\n      <td>Cythulianmixseth III</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>True</td>\n      <td>Jonny</td>\n      <td>2.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n# Indexes\n\nIndex objects hold axis labels and other metadata (like axis names). Any labels you use to construct a Series or DataFrame are converted to an Index.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndf.index\n```\n\n::: {.cell-output .cell-output-display execution_count=189}\n```\nRangeIndex(start=0, stop=5, step=1, name='student')\n```\n:::\n:::\n\n\nIndex objects are immutable, but they can be accessed like arrays and behave more like fixed sets:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nlabels = pd.Index(np.arange(4))\n\nseries = pd.Series(np.random.randn(4), index=labels)\n\nseries.index is labels\n```\n\n::: {.cell-output .cell-output-display execution_count=190}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nlabels2 = pd.Index([2, 3, 5, 6])\nprint(labels.difference(labels2))\nprint(labels.is_unique)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex([0, 1], dtype='int64')\nTrue\n```\n:::\n:::\n\n\n# Essential Functionality\n\n## Reindex\n\nWe can modify the Index of a Series or DataFrame using `reindex`:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nseries2 = series.reindex(['a', 'b', 'c', 'd'])\nseries2\n```\n\n::: {.cell-output .cell-output-display execution_count=192}\n```\na   NaN\nb   NaN\nc   NaN\nd   NaN\ndtype: float64\n```\n:::\n:::\n\n\nWe can also fill interpolate values when reindexing with a small subset of labels:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nseries = pd.Series([\"blue\", \"purple\", \"yellow\"], index=[0, 2, 4])\nseries.reindex(np.arange(6), method=\"ffill\")\n```\n\n::: {.cell-output .cell-output-display execution_count=193}\n```\n0      blue\n1      blue\n2    purple\n3    purple\n4    yellow\n5    yellow\ndtype: object\n```\n:::\n:::\n\n\n## Drop Values\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nseries = pd.Series(np.arange(5.0), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\nseries_drop = series.drop(\"c\")\n\nseries_drop\n```\n\n::: {.cell-output .cell-output-display execution_count=194}\n```\na    0.0\nb    1.0\nd    3.0\ne    4.0\ndtype: float64\n```\n:::\n:::\n\n\nWithin a DataFrame, we can drop from the rows or the columns using the `axis` argument:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndf = pd.DataFrame(\n    np.arange(16).reshape((4, 4)),\n    index=[\"Ohio\", \"Colorado\", \"Utah\", \"New York\"],\n    columns=[\"one\", \"two\", \"three\", \"four\"],\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=195}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>two</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Ohio</th>\n      <td>0</td>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Colorado</th>\n      <td>4</td>\n      <td>5</td>\n      <td>6</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>Utah</th>\n      <td>8</td>\n      <td>9</td>\n      <td>10</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>New York</th>\n      <td>12</td>\n      <td>13</td>\n      <td>14</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo drop from rows:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ndf.drop(['Colorado', 'Ohio'])\n```\n\n::: {.cell-output .cell-output-display execution_count=196}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>two</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Utah</th>\n      <td>8</td>\n      <td>9</td>\n      <td>10</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>New York</th>\n      <td>12</td>\n      <td>13</td>\n      <td>14</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo drop from columns:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndf.drop(['two'], axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=197}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Ohio</th>\n      <td>0</td>\n      <td>2</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Colorado</th>\n      <td>4</td>\n      <td>6</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>Utah</th>\n      <td>8</td>\n      <td>10</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>New York</th>\n      <td>12</td>\n      <td>14</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nKeep in mind these return a **copy** of a DataFrame by default. If you need to save these results then assign them to a variable.\n\n## Indexing, Selection, Filtering\n\n### Indexing\n\nThe preferred way to select data by Index labels is by using the special `loc` operator:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nseries = pd.Series(np.arange(4.0), index=[\"a\", \"b\", \"c\", \"d\"])\n\nseries.loc[[\"b\", \"a\", \"d\"]]\n```\n\n::: {.cell-output .cell-output-display execution_count=198}\n```\nb    1.0\na    0.0\nd    3.0\ndtype: float64\n```\n:::\n:::\n\n\n:::{.callout-note}\n# Book Note\n\nThe reason to prefer `loc` is because of the different treatment of integers when indexing with `[]`. Regular `[]`-based indexing will treat integers as labels if the index contains integers, so the behavior differs depending on the data type of the index. - Wes McKinney\n:::\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nseries = pd.Series([1, 2, 3], index=[2, 0, 1])\nseries2 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nprint(series[[0, 1, 2]])\nprint(series2[[0, 1, 2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    2\n1    3\n2    1\ndtype: int64\na    1\nb    2\nc    3\ndtype: int64\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/7s/plv7qn294jg_4c9nxj_69_380000gn/T/ipykernel_79201/4284678342.py:5: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n```\n:::\n:::\n\n\nNote how in the first indexing call the result is executed according to the actual value of the labels, not the integer position. In the second call, the result is executed according to the integer position because the Index is not integer-based. `loc` removes this ambiguity by throwing an error if the Index does not contain integers.\n\nWe can also do integer-based indexing using `iloc`:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nseries2.iloc[0:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=200}\n```\na    1\nb    2\ndtype: int64\n```\n:::\n:::\n\n\n:::{.callout-note}\n# Book Note\n\nIt can be a common newbie error to try to call `loc` or `iloc` like functions rather than \"indexing into\" them with square brackets. The square bracket notation is used to enable slice operations and to allow for indexing on multiple axes with DataFrame objects. - Wes McKinney\n:::\n\n### Filtering\n\nThe most common and convenient way to do filtering in `pandas` is to supply a Boolean array. We can also rows that meet a certain condition using Boolean arrays:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndf[df < 5] = 9999\n\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=201}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>two</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Ohio</th>\n      <td>9999</td>\n      <td>9999</td>\n      <td>9999</td>\n      <td>9999</td>\n    </tr>\n    <tr>\n      <th>Colorado</th>\n      <td>9999</td>\n      <td>5</td>\n      <td>6</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>Utah</th>\n      <td>8</td>\n      <td>9</td>\n      <td>10</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>New York</th>\n      <td>12</td>\n      <td>13</td>\n      <td>14</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Selection with `loc` and `iloc`\n\nNow here's the juicy part. Remember our SQL lab with Python? Remember having to write several sets of brackets to get the rows and then the columns. `loc` and `iloc` allow you to do both at the same time similar to how we select values in R dataframes:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Selecting specific indexes\ndf.loc[['Colorado', 'New York']]\n```\n\n::: {.cell-output .cell-output-display execution_count=202}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>two</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Colorado</th>\n      <td>9999</td>\n      <td>5</td>\n      <td>6</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>New York</th>\n      <td>12</td>\n      <td>13</td>\n      <td>14</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Selecting a specific index and two specific columns\ndf.loc[\"Colorado\", [\"two\", \"three\"]]\n```\n\n::: {.cell-output .cell-output-display execution_count=203}\n```\ntwo      5\nthree    6\nName: Colorado, dtype: int64\n```\n:::\n:::\n\n\nAnd now with `iloc`:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Selecting indexes based on integer position\ndf.iloc[[2, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=204}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>one</th>\n      <th>two</th>\n      <th>three</th>\n      <th>four</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Utah</th>\n      <td>8</td>\n      <td>9</td>\n      <td>10</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>Colorado</th>\n      <td>9999</td>\n      <td>5</td>\n      <td>6</td>\n      <td>7</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Selecting a specific index and three specific columns using integers\ndf.iloc[2, [3, 0, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=205}\n```\nfour    11\none      8\ntwo      9\nName: Utah, dtype: int64\n```\n:::\n:::\n\n\nWe can use Boolean arrays with `loc` but not `iloc`. Here is an example with our SQL lab:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nfrom pathlib import Path\n\npath = Path(\"data\")\ndf = pd.read_csv(path / \"AWProduct.csv\", low_memory=False)\n\n# Select ProductName, DealerPrice where DealerPrice > 10\ndf.loc[df[\"DealerPrice\"] > 10, [\"ProductName\", \"DealerPrice\"]].head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=206}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ProductName</th>\n      <th>DealerPrice</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>211</th>\n      <td>Sport-100 Helmet, Red</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>212</th>\n      <td>Sport-100 Helmet, Red</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>213</th>\n      <td>Sport-100 Helmet, Red</td>\n      <td>20.9940</td>\n    </tr>\n    <tr>\n      <th>214</th>\n      <td>Sport-100 Helmet, Black</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>215</th>\n      <td>Sport-100 Helmet, Black</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>216</th>\n      <td>Sport-100 Helmet, Black</td>\n      <td>20.9940</td>\n    </tr>\n    <tr>\n      <th>219</th>\n      <td>Sport-100 Helmet, Blue</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>220</th>\n      <td>Sport-100 Helmet, Blue</td>\n      <td>20.1865</td>\n    </tr>\n    <tr>\n      <th>221</th>\n      <td>Sport-100 Helmet, Blue</td>\n      <td>20.9940</td>\n    </tr>\n    <tr>\n      <th>225</th>\n      <td>Long-Sleeve Logo Jersey, S</td>\n      <td>28.8404</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we need to select a specific value by row and column label:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndf.at[211, \"ProductName\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=207}\n```\n'Sport-100 Helmet, Red'\n```\n:::\n:::\n\n\nOr by integer position:\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ndf.iat[211, 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=208}\n```\n212\n```\n:::\n:::\n\n\n# Function Application and Mapping (Preview)\n\nWe're starting to get just a little more complicated here, but as long as you understand what functions are doing these next few sections should make sense. Here is just a preview of what we can cover later: function mapping!\n\nAt a high level, `pandas` allows us to *apply* custom functions that can accept array-like arguments to entire columns or rows. Now wait, can't we just use for-loops for this? We could, but it wouldn't take advantage of the computational speed-ups we get by utilizing `numpy` and vectorized operations. \n\nHere is a demonstration of applying normalization to all the values in our data:\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\ndata = {\n    \"x\": {\"Yang\": 1.0, \"Yin\": 3.0, \"Jupiter\": 6.0},\n    \"y\": {\"Yang\": 2.0, \"Yin\": 4.0, \"Jupiter\": 7.0},\n    \"z\": {\"Yang\": 3.0, \"Yin\": 5.0, \"Jupiter\": 3.0},\n}\ndf = pd.DataFrame(data)\n\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=209}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n      <th>z</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Yang</th>\n      <td>1.0</td>\n      <td>2.0</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>Yin</th>\n      <td>3.0</td>\n      <td>4.0</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>Jupiter</th>\n      <td>6.0</td>\n      <td>7.0</td>\n      <td>3.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndef normalize(x):\n    return (x - x.mean()) / x.std()\n\n\ndf.apply(normalize)\n```\n\n::: {.cell-output .cell-output-display execution_count=210}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n      <th>z</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Yang</th>\n      <td>-0.927173</td>\n      <td>-0.927173</td>\n      <td>-0.577350</td>\n    </tr>\n    <tr>\n      <th>Yin</th>\n      <td>-0.132453</td>\n      <td>-0.132453</td>\n      <td>1.154701</td>\n    </tr>\n    <tr>\n      <th>Jupiter</th>\n      <td>1.059626</td>\n      <td>1.059626</td>\n      <td>-0.577350</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}