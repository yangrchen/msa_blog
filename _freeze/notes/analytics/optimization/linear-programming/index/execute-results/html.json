{
  "hash": "4ba5a46a7b65e466add46477cd3873e8",
  "result": {
    "markdown": "---\ntitle: Linear Programming\ndate: 01/11/2023\n---\n\n# Example Problem\n\nDahlby Outfitters wants to introduce a new trail mix. Each ingredient\ncontain amounts of vitamins, minerals, proteins, and calories (must\ncontain at least the amount shown in table). Product needs to have\ncertain minimal nutritional profile. Want to find the optimal mix that\nminimizes cost.\n\n![Example Information](images/example-info.png){#fig-example-info}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom gurobipy import Model, GRB\n\nm = Model(\"Nutrition Example\")\n\n# Create variables\ns = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=\"seeds\")\nr = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=\"raisins\")\nf = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=\"flakes\")\np = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=\"pecans\")\nw = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=\"walnuts\")\n\n# Add constraints\nm.addConstr(10 * s + 20 * r + 10 * f + 30 * p + 20 * w >= 20, \"Vitamins\")\nm.addConstr(5 * s + 7 * r + 4 * f + 9 * p + 2 * w >= 10, \"Minerals\")\nm.addConstr(1 * s + 4 * r + 10 * f + 2 * p + 1 * w >= 15, \"Protein\")\nm.addConstr(500 * s + 450 * r + 160 * f + 300 * p + 500 * w >= 600, \"Calories\")\n\n# Set objective\nm.setObjective(4 * s + 5 * r + 3 * f + 7 * p + 6 * w, GRB.MINIMIZE)\n\nm.optimize()\n\nfor v in m.getVars():\n    print(f\"{v.varName} {v.x}\")\nprint(f\"Obj: {m.objVal}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRestricted license - for non-production use only - expires 2025-11-24\nGurobi Optimizer version 11.0.0 build v11.0.0rc2 (mac64[arm] - Darwin 23.2.0 23C71)\n\nCPU model: Apple M2 Pro\nThread count: 12 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 4 rows, 5 columns and 20 nonzeros\nModel fingerprint: 0xbd9b0c7e\nCoefficient statistics:\n  Matrix range     [1e+00, 5e+02]\n  Objective range  [3e+00, 7e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+01, 6e+02]\nPresolve time: 0.00s\nPresolved: 4 rows, 5 columns, 20 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    0.0000000e+00   9.250000e+01   0.000000e+00      0s\n       3    7.5357995e+00   0.000000e+00   0.000000e+00      0s\n\nSolved in 3 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  7.535799523e+00\nseeds 0.47732696897374705\nraisins 0.33412887828162285\nflakes 1.3186157517899761\npecans 0.0\nwalnuts 0.0\nObj: 7.535799522673031\n```\n:::\n:::\n\n\n# Binding Constraints and Sensitivity\n\nA constraint is **binding** if the LHS of a constraint equals the RHS of the constraint. We can get this from Gurobi which labels these constraints as slack--the difference between the LHS and RHS:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfor c in m.getConstrs():\n    print(f\"{c.ConstrName}: {c.Slack}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVitamins: -4.642004773269688\nMinerals: 0.0\nProtein: 0.0\nCalories: 0.0\n```\n:::\n:::\n\n\nHow sensitive is the solution to changes in the parameter values in the constraints? This is referred to as **shadow price**.\n\nHow sensitive is the solution to changes in the coefficients in the objective function? This is referred to as **reduced cost**.\n\n# Shadow Price\n\nIn our previous furniture example, we had two binding constraints: fabrication and table demand.\n\nWe want to see what happens when we incrase fabrication by 1 hour, keeping all else constant.\n\nThe original fabrication is 1850 and the objective value is 8400. If we increase fabrication by 1 then the objective value is now 8404. As we increase fabrication by 1 hour then we will see a increase in profit by $4.\n\nIf we were to change a constraint that is **not** binding, then our objective value does not change.\n\nThe shadow price of a constraint indicates the amount by which the objective function value changes givena  unit increase or decrease in the RHS of the constraint, assuming all other parameters remain constant. Shadow prices only hold for linear optimizations and are always zero for nonbinding constraints.\n\n## Slack vs. Pi in Python\n\nIf a constraint is binding (RHS = LHS), then the slack for the constraint is 0. Constraints with nonbinding constraints will have a nonzero value for slack. When the constraint is binding, then Pi will give the shadow price for that constraint.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nshadow_prices = m.getAttr(\"Pi\")\nm.printAttr(\"Pi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  Constraint           Pi \n-------------------------\n    Minerals     0.490453 \n     Protein    0.0560859 \n    Calories   0.00298329 \n```\n:::\n:::\n\n\n# Reduced Cost\n\n**Reduced cost** is the amount by which an objective function coefficient would have to improve (increase for maximization, decrease for minimization) before it would be possible for a corresponding variable to assume a positive value in the optimal solution.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfor v in m.getVars():\n    print(f\"{v.VarName}: {v.RC}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nseeds: 0.0\nraisins: 0.0\nflakes: 0.0\npecans: 1.5787589498806665\nwalnuts: 3.4713603818615764\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}